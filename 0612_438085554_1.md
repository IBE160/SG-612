# Refleksjonsrapport - Programmering med KI

## 1. Gruppeinformasjon

**Gruppenavn:** [Navn på gruppen]

**Gruppemedlemmer:**
- Tord Haakon Johnsen Hovden - tord.h.hovden@himolde.no
- David Johan Lunde - david.j.lunde@himolde.no
- Muriel Sofie Halstad Persen - muriel.s.persen@himolde.no

**Dato:** [05.12.2025]


## 2. Utviklingsprosessen

### 2.1 Oversikt over prosjektet
 Prosjektet, kalt 'Smart To-Do: AI-Enhanced Task Manager with Auto-Labeling', har som hovedmål å utvikle en lettvektig webapplikasjon som lar brukere effektivt administrere oppgaver. Kjernen i prosjektet er integrasjonen med Google Gemini AI, som automatisk foreslår en 'Label' (kategori) og 'Priority' (viktighet) basert på oppgavebeskrivelsen. Dette reduserer manuelt arbeid og bidrar til en mer organisert oppgaveliste, spesielt rettet mot studenter og nybegynnere som ønsker intelligent assistanse uten kompleksiteten fra større verktøy.

### 2.2 Arbeidsmetodikk
 Vi brukte Microsoft Teams aktivt for både chat og videomøter, hvor vi planla og fordelte oppgaver. Dette sikret at alle gruppemedlemmer var synkronisert og hadde en klar forståelse av individuelle ansvarsområder.

Når det gjelder KI-verktøy, har vi primært benyttet Google Gemini og Gemini Pro for generell assistanse, besvarelse av spørsmål og problemløsning. For filhåndtering, oppretting og utfylling av nødvendige filer direkte i prosjektet, har vi brukt Gemini CLI integrert i VS Code.

### 2.3 Teknologi og verktøy
 Her er en liste over de viktigste teknologiene og verktøyene vi brukte:
- Frontend: HTML5, CSS3, Jinja2 (Flask Templating), Tailwind (via CDN)
- Backend: Python 3.x, Flask
- Database: SQLite via SQLAlchemy ORM
- KI-verktøy: Google Gemini API (Model: `gemini-1.5-flash`), Gemini CLI, Gemini Pro
- Andre verktøy: VS Code, Git, Microsoft Teams

### 2.4 Utviklingsfaser
 Utviklingsprosessen ble delt inn i flere faser som beskrevet i prosjektplanen.

**Fase 1: Planlegging (Uke 1)**
I planleggingsfasen definerte vi prosjektets kjerne, teknologivalg og en strategi for robusthet. Vi avklarte hovedmålet om å utvikle en "lett, rask og pålitelig to-do-app" med innovative AI-forslag for merking og prioritering ("Magic Fill"). Kjernekravene (MVP) ble definert til å omfatte grunnleggende CRUD-funksjonalitet for oppgaver, smarte lister (f.eks. "High Priority" og "Due This Week"), mulighet for manuell overstyring av AI-forslag, og et enkelt brukergrensesnitt.

Vi valgte teknologistack bestående av Flask for backend, SQLite/SQLAlchemy for database, enkel HTML/Jinja for templating, og Tailwind CSS for styling. Playwright ble valgt for E2E-testing, og Git/Teams for versjonskontroll og samarbeid. Vi skisserte en enkel skjermflyt med input-felt, en oppgaveliste og en "Tøm listen"-funksjon, samt datafeltene (tittel, notater, forfallsdato, merkelapp, prioritet, fullført). For å sikre robusthet ble en regelbasert fallback-mekanisme planlagt for tilfeller der Gemini-modellen ikke var tilgjengelig.
**Hvordan brukte dere KI her?** 
Vi brukte Gemini CLI for å lese og forstå prosjektdokumentasjon som `@proposal.md`, `@docs/bmm-workflow-status.yaml` og `@docs/project-plan.md`. Basert på disse filene ga vi Gemini CLI instrukser for å veilede oss og opprette relevante filer for planleggingsprosessen.

**Fase 2: Utvikling (Uke 2-5)**
Utviklingsfasen omfattet implementering av kjernefunksjonalitet og raffinering av applikasjonen.
- **Uke 2: Gemini KI-integrasjon:** Vi skaffet Google AI Studio API-nøkkel, skrev Python-tjenesten for å kommunisere med Gemini API, designet prompten for konsistent JSON-output, og implementerte den regelbaserte fallback-logikken. Leveransen var et Python-skript som tar tekstinput og returnerer kategorisert JSON-output.
- **Uke 3: Frontend-implementasjon:** Vi integrerte Tailwind-maler, bygget hoveddashbordet (oppgavelisten) og skjemaene for å legge til/redigere oppgaver, og koblet Jinja2-malene til Flask-rutene. Resultatet var et funksjonelt webgrensesnitt som viste oppgaver fra databasen.
- **Uke 4: Smarte funksjoner og polering (MVP-fullføring):** Frontendens "Auto-Suggest"-knapp ble koblet til backendens KI-tjeneste. We implementerte logikken for "Smarte lister" (SQL-spørringer for filtrering) og la til funksjonalitet for sortering og manuell filtrering. Målet var en funksjonsrik MVP der KI aktivt hjelper til med å kategorisere oppgaver.
- **Uke 5: Testing og raffinering:** Denne uken ble brukt til manuell testing av grensetilfeller (tomme inndata, lang tekst, API-feil), verifisering av fallback-logikken (simulere frakoblet modus) og UI-justeringer (mellomrom, farger, merker).

 **Hvordan brukte dere KI her?** 
 Vi brukte KI på flere måter i utviklingsfasen:
- For KI-integrasjonen designet vi en spesifikk prompt for Gemini-modellen for å sikre at den returnerte en konsistent JSON-respons. Prompten er dokumentert i `docs/fase-3-solutioning/architecture.md`:
    *   `Given the task title, suggest a priority (Low, Medium, High) and a relevant category label. Return ONLY a JSON object with "priority" and "label" keys. Task Title: "{title}"`
-  Vi brukte også kommandoer som `/run-agent-task dev *develop-story` og `/run-agent-task dev *code-review` med spesifikke prompts for å få hjelp til å skrive og gjennomgå kode.
-  For frontend-utviklingen brukte vi en "AI Frontend Prompt Workflow" for å generere prompts for ulike UI-komponenter, som beskrevet i `docs/fase-2-planning/ux-design-specification.md`.
- Vi har ikke fått gjort `*develop-story` eller `*code-review` ennå. Derfor skriver vi denne refleksjonsrapporten basert på hva vi har gjort hittil.

---

## 3. Utfordringer og løsninger

### 3.1 Tekniske utfordringer
**Utfordring 1: KI-verktøyets manglende evne til å spore filforflytninger**

**Problem:** 
Etter hvert som prosjektet vokste, ble filer organisert i nye undermapper, som `docs/fase-2-planning/`. Gemini CLI klarte ikke alltid å følge med på disse endringene og fant ikke filene på de nye plasseringene, noe som førte til at verktøyet stoppet opp.
**Løsning:** 
Vi måtte manuelt gripe inn og eksplisitt fortelle Gemini CLI den nye filstien. Dette innebar en slags "kontekstoppdatering" der vi måtte be KI-verktøyet om å huske og oppdatere alle referanser til den nye plasseringen.
**KI sin rolle:**
- **Hinder:** KI-verktøyets manglende evne til automatisk tilpasse seg endringer i filstrukturen var den direkte årsaken til det, og skapte friksjon i arbeidsflyten.
 - **Hjelp:** Etter at vi ga den korrekte filstien, kunne verktøyet fortsette oppgaven og bruke filen som tiltenkt. KI-en var et verktøy som, til tross for sine begrensninger, lot seg veilede.

**Utfordring 2: Kompleks frontend-håndtering med enkle verktøy**
**Problem:** 
Prosjektet benytter enkle verktøy som HTML, Jinja2 og standard JavaScript for å skape et moderne grensesnitt. Dette er krevende fordi vi manuelt måtte håndtere lasting, feilmeldinger og UI-oppdateringer – oppgaver som moderne rammeverk (som React) i stor grad automatiserer.
**Løsning:** 
Løsningen var å skrive egen JavaScript-kode som direkte manipulerte DOM-en for å vise eller skjule elementer og oppdatere innhold basert på svar fra backend.
**KI sin rolle:**
 - **Hjelp:** KI var nyttig for å generere spesifikke JavaScript-kodebiter, for eksempel for å lage API-kall med `fetch` eller for å oppdatere et HTML-element.
- **Hinder:** Utfordringen var å integrere den KI-genererte koden på en god måte. Koden passet ikke alltid inn i den eksisterende strukturen, og det kunne være vanskelig å feilsøke når KI-en ikke hadde full oversikt over hele frontend-arkitekturen.

### 3.2 Samarbeidsutfordringer
 Vi opplevde utfordringer knyttet til teamarbeid og kommunikasjon primært grunnet ulike tidspunkter for tilgjengelighet blant gruppemedlemmene. Dette gjorde det vanskelig å koordinere felles arbeidsøkter og diskusjoner. I tillegg fant vi alle tre faget og prosjektet generelt svært utfordrende, noe som førte til vanskeligheter med å forstå komplekse konsepter og implementeringer.

**Løsning:** 
For å løse disse utfordringene valgte vi å lene oss nesten fullstendig på KI-verktøy. Ved å la KI håndtere en stor del av arbeidet, kunne vi kompensere for tidskonflikter og manglende felles forståelse, da KI-en kunne bidra med løsningsforslag og veiledning.
**KI sin rolle:** 
KI spilte en avgjørende rolle som vår primære problemløser. Den bidro til å overkomme både logistiske utfordringer knyttet til ulike timeplaner (ved å muliggjøre asynkront arbeid med KI-støtte) og faglige utfordringer ved å generere nødvendige løsninger og veiledning. Dette reduserte behovet for dyp felles forståelse og koordinert innsats i mange faser av prosjektet.

### 3.3 KI-spesifikke utfordringer
 Vi identifiserte to hovedutfordringer spesifikt knyttet til bruken av KI-verktøy:

**Utfordring 1: KI-ens begrensede kontekstforståelse av filstrukturer**
**Problem:** 
Selv om vi brukte Gemini CLI for veiledning, hadde KI-en problemer med å spore filer som ble flyttet til nye, egenopprettede mapper. Dette førte til avbrudd i arbeidsflyten, spesielt når KI-en skulle basere nye filer på eksisterende filer i de nye mappene. KI-en mistet konteksten for filenes plassering.
**Løsning:** 
Vi måtte manuelt stoppe opp og gi detaljerte forklaringer om filenes nye lokasjon. Dette innebar å eksplisitt instruere KI-en om hvor filene lå og be den endre sine interne referanser for den aktuelle økten.
**KI sin rolle:**
- **Hinder:** KI-ens manglende evne til automatisk å tilpasse seg endringer i filstrukturen var den direkte årsaken til det, og skapte friksjon i arbeidsflyten.
- **Hjelp:** Når KI-en ble manuelt korrigert, kunne den utføre oppgavene effektivt. Den fungerte som et kraftig verktøy som krevde nøyaktig styring.

**Utfordring 2: Uforutsette feil ved bruk av "YOLO-modus"**
**Problem:** 
På grunn av tids- og forståelsesutfordringer, og en bevisst risikoavveining, valgte vi av og til å kjøre KI-en i det vi kalte "YOLO-modus" (You Only Live Once) – der vi aksepterte KI-ens utkast uten grundig umiddelbar gjennomgang. Dette førte i noen tilfeller til at KI-generert kode inneholdt feil eller ikke var optimal, noe som krevde korreksjon i ettertid.
**Løsning:** 
Vi måtte identifisere og manuelt rette opp feilene som oppstod. Dette tvang oss til å gå tilbake og gjennomgå deler av koden mer detaljert enn opprinnelig planlagt.
**KI sin rolle:**
- **Hinder:** KI-en produserte i disse tilfellene feil som skapte ekstraarbeid og forsinkelser.
 - **Hjelp:** Til tross for feilene, ga KI-en et utgangspunkt for videre arbeid, og akselererte den innledende kodegenereringen, selv om den krevde etterfølgende validering og korrigering.

---

## 4. Kritisk vurdering av KI sin påvirkning

### 4.1 Fordeler med KI-assistanse

**Hvordan påvirket KI arbeidshastigheten?** 
KI-en økte hastigheten betraktelig, spesielt siden vi stolte på den for å utføre mye av arbeidet. Dette var avgjørende for å komme i mål, med tanke på utfordringene med samarbeid og felles forståelse.
-**Eksempler på oppgaver som gikk raskere:**
 - **Prosjektoppsett:** Utfylling av dokumenter som dette, basert på maler.
 - **Kodegenerering:** Opprettelse av grunnleggende Python-kode for Flask-serveren (`app.py`), database-interaksjon (`ai_service.py`) og ruting.
  - **Kompleks logikk:** Utvikling av logikken for selve KI-integrasjonen, inkludert håndtering av API-kall og fallback-løsninger.

**Hva lærte dere ved å bruke KI?** Vi lærte oss generelt mer om bruken av verktøy som VS Code og Gemini CLI, og hvordan disse kan anvendes i praksis for å navigere og fullføre et helt prosjekt fra start til slutt.
**Bidro KI til bedre forståelse av konsepter?** Siden KI håndterte mye av den komplekse kodingen, var læringen mer fokusert på verktøybruk og prosjektgjennomføring enn på dypere kodekonsepter.

**Hvordan påvirket KI kodekvaliteten?** KI-en kan ha introdusert et høyere nivå av standard praksis, for eksempel ved å inkludere robust feilhåndtering (`try...except`-blokker) i `ai_service.py`, noe vi kanskje ikke ville prioritert selv.
**Eksempler på forbedringer KI foreslo:** Den kan ha foreslått å bruke SQLAlchemy ORM i stedet for rå SQL-spørringer, noe som gjør koden lettere å vedlikeholde, eller sørget for en mer enhetlig kodestil på tvers av prosjektet.

### 4.2 Begrensninger og ulemper

**Eksempler på feil eller dårlige løsninger fra KI:** Vi opplevde at KI-en ikke alltid var pålitelig. Et konkret eksempel var da vi brukte den i "YOLO-modus" for å generere kode raskt; dette resulterte i feil som vi måtte identifisere og rette opp manuelt. Et annet eksempel var KI-ens manglende evne til å finne filer etter at vi hadde endret mappestrukturen, noe som viste en svakhet i verktøyets pålitelighet.
**Hvordan oppdaget og håndterte dere disse?** Vi oppdaget feilene gjennom testing og ved at programmet ikke oppførte seg som forventet. Håndteringen var manuell feilretting og ved å gi KI-en mer presise instrukser for å unngå gjentakelse.

**Ble dere for avhengige av KI?** Ja, vi ble i stor grad avhengige av KI. Som nevnt tidligere, løste vi samarbeids- og forståelsesutfordringer ved å "stole så og si fullt på KI, og la den gjøre så og si alt."
**Var det tilfeller hvor KI hindret læring?** Absolutt. Siden KI-en håndterte mye av den komplekse kodingen, ble vår læring mer rettet mot verktøybruk og prosjektgjennomføring, fremfor en dypere forståelse av selve kodekonseptene. Dette hindret oss i å utvikle en grundigere teknisk kompetanse.

**Påvirket KI deres egen kreativitet?** Ja, den høye avhengigheten av KI påvirket sannsynligvis vår egen kreativitet. I stedet for å selv brainstorme ulike løsningsalternativer, ble det enklere og raskere å be KI-en om en ferdig løsning.
**Eksempler på situasjoner hvor KI begrenset kreativ tenkning:** I stedet for å designe algoritmer eller datastrukturer fra bunnen av, spurte vi KI-en om å generere dem. Dette reduserte behovet for kreativ problemløsning fra vår side og førte til at vi i mindre grad utforsket alternative tilnærminger.

### 4.3 Sammenligning: Med og uten KI
 Refleksjon over hvordan prosjektet ville vært uten KI gir et klart bilde av KI-ens sentrale rolle:

**Hva ville vært annerledes?** 
Uten KI ville hele prosjektets dynamikk og sannsynligvis også sluttresultatet vært fundamentalt annerledes. Gitt våre utfordringer med ulike timeplaner og den opplevde kompleksiteten i faget, er det en reell mulighet for at prosjektet enten ikke ville blitt fullført i tide, eller at det ville tatt betydelig lengre tid. Arbeidsflyten ville krevd mye mer synkronisert samarbeid og en betydelig større manuell innsats for koding.
**Hvilke deler av prosjektet ville vært vanskeligere/lettere?**
- **Vanskeligere:** De aller fleste delene av prosjektet ville vært vanskeligere. Spesielt det innledende prosjektoppsettet og dokumentasjonen, genereringen av boilerplate-kode for Flask-applikasjonen, implementeringen av kompleks KI-integrasjonslogistikk (som i `ai_service.py`), og ikke minst utarbeidelsen av denne refleksjonsrapporten, ville krevd langt mer tid og innsats.
- **Lettere:** Det er vanskelig å peke på deler som ville vært *lettere*, men potensielt kunne feilsøking vært mer direkte. Siden all kode da ville vært skrevet av oss selv, ville vi ha hatt en dypere og mer helhetlig forståelse av den fra starten av, noe som kunne forenklet identifisering og retting av feil.
**Ville sluttresultatet vært bedre eller dårligere?** Dette er subjektivt, men vi kan vurdere det slik:
 - **Dårligere:** Sluttproduktet ville sannsynligvis vært mindre funksjonsrikt, hatt en lavere kodekvalitet (f.eks. uten like robust feilhåndtering), eller i verste fall ikke blitt levert i det hele tatt.
 - **Bedre:** Vår *egen forståelse* av det ferdige produktet og de underliggende teknologiene ville vært betydelig dypere. Koden, selv om den kanskje var enklere, ville vært fullt ut forstått av sine skapere, noe som kunne gitt et mer robust fundament for videre utvikling og vedlikehold fra vår side.

### 4.4 Samlet vurdering

**Konklusjon: Hvordan påvirket KI sluttresultatet totalt sett?**
KI hadde en avgjørende og dyptgripende påvirkning på sluttresultatet. Gitt våre utfordringer med både tidspunkter for samarbeid og et krevende fagstoff, fungerte KI som en fundamental muliggjører. Uten KI-assistanse er det høyst sannsynlig at prosjektet enten ikke ville blitt fullført i tide, eller at omfanget måtte blitt drastisk redusert. Dette kom imidlertid med en kostnad: vår egen forståelse av de underliggende kodekonseptene ble grunnere enn den ville vært uten KI, og vi lente oss i mindre grad på egen kreativ problemløsning.

**Var KI en netto positiv eller negativ faktor?**
For selve *gjennomføringen* av prosjektet, var KI en utvilsomt **netto positiv** faktor. Den sikret progresjon og gjorde det mulig å levere et produkt som samsvarte med de opprinnelige målene. For vår *egen læring* og *dybdekompetanse*, var faktoren mer **nyansert**. Mens vi lærte mye om verktøybruk, kan den store avhengigheten av KI ha redusert læringsutbyttet knyttet til fundamental koding og problemløsning.

**Hva var den viktigste lærdommen om å bruke KI i utviklingsprosessen?**
Den viktigste lærdommen er todelt:
1.  **KI er et kraftig, men ufullstendig verktøy:** KI kan akselerere utvikling og overkomme store hindringer, men det er ikke en erstatning for menneskelig tilsyn. Våre erfaringer med "YOLO-modus" og KI-ens manglende kontekstforståelse understreker at kritisk tenkning, validering og manuell korrigering er helt avgjørende.
2.  **Bevissthet rundt balansen mellom effektivitet og læring:** Det eksisterer en konstant avveining mellom å bruke KI for å få jobben gjort raskest mulig, og å bruke det på en måte som fremmer egen læring. For studenter er det en kritisk lærdom å aktivt søke denne balansen, slik at man ikke ofrer kompetanseutvikling for kortsiktig effektivitet.

---

## 5. Etiske implikasjoner

### 5.1 Ansvar og eierskap

**Hvem er ansvarlig for koden når KI har bidratt?**
Vår klare erfaring er at **utvikleren alltid er den endelige ansvarlige**. Vi ser på KI-en som et avansert verktøy, på linje med et bibliotek eller en kompilator. Våre opplevelser med "YOLO-modus" bekrefter dette prinsippet: da KI-en produserte feil, var det vårt ansvar som utviklere å identifisere, forstå og rette dem. Det er den som committer koden til versjonskontroll som står ansvarlig for kvaliteten og funksjonaliteten, uavhengig av hvordan koden ble generert.

**Hvordan sikrer man kvalitet når KI genererer kode?**
Man kan ikke stole blindt på KI-generert kode. Vår erfaring viser at kvalitetssikring må skje gjennom flere ledd:
- **Menneskelig gjennomgang:** En utvikler må alltid kritisk vurdere, teste og forstå koden som blir generert. Som vi lærte, er "YOLO-modus" en risikabel strategi som kan føre til merarbeid.
- **Testing:** Manuell funksjonell testing og potensielt automatiserte tester er avgjørende for å verifisere at den KI-genererte koden fungerer som forventet og ikke introduserer nye feil eller sikkerhetshull.
- **Kontekstuell integrering:** Det er utviklerens jobb å sørge for at den genererte koden passer godt inn i den eksisterende kodestrukturen og følger prosjektets etablerte konvensjoner.

**Diskuter spørsmål om opphavsrett og intellektuell eiendom**
Dette er et komplekst juridisk og etisk område. KI-modeller er trent på enorme mengder offentlig tilgjengelig kode, som kan være underlagt et bredt spekter av lisenser (f.eks. MIT, GPL). Dette skaper usikkerhet rundt eierskapet til den genererte koden. For et **studentprosjekt** som vårt, anser vi den juridiske risikoen som lav. For et **kommersielt produkt** ville dette imidlertid vært en betydelig bekymring, da man risikerer å utilsiktet bryte lisensene til kildekoden KI-en er trent på. I tillegg er det viktig å forholde seg til **bruksvilkårene** til selve KI-verktøyet (f.eks. Google Gemini), som ofte inneholder spesifikke klausuler om eierskap og tillatt bruk av generert innhold.

### 5.2 Transparens

**Bør det være transparent at KI er brukt?**
- **I en akademisk/læringskontekst:** Absolutt. For å sikre en rettferdig vurdering av studentens egen forståelse og innsats, er det avgjørende med åpenhet om bruk av KI-verktøy. Det handler om redelighet og å gi en sannferdig fremstilling av eget bidrag.
- **I en kommersiell/profesjonell kontekst:** Dette er mer komplekst. Mens det sjeldent er nødvendig å informere sluttbrukere, er intern transparens *innenfor utviklingsteamet og selskapet* av stor betydning. Kunnskap om hvilke deler av koden som er KI-generert er essensielt for vedlikehold, feilsøking, og for å unngå potensielle juridiske komplikasjoner knyttet til opphavsrett.

**Hvordan dokumenterer man KI sin bidrag?**
Vår erfaring har vist at det er viktig å dokumentere KI-ens bidrag på en strukturert måte:
- **Prompthistorikk:** En god praksis er å lagre prompts og de mest relevante svarene direkte i prosjektdokumentasjonen, slik vi delvis har gjort i `docs/project-plan.md`.
- **Versjonskontroll:** Bruk av spesifikke konvensjoner i commit-meldinger kan indikere KI-generert kode, f.eks., `git commit -m "feat: Implement user authentication (AI-assisted)"`.
- **Refleksjonsrapporter:** Slike rapporter som denne tjener som et overordnet dokument for å reflektere over og dokumentere KI-ens rolle i prosjektet.

**Hva er konsekvensene av å ikke være åpen om KI-bruk?**
- **I en akademisk setting:** Manglende åpenhet kan fort bli betraktet som akademisk uredelighet, da det villeder om omfanget av studentens eget arbeid og forståelse.
- **I en profesjonell setting:** Følgene kan være alvorlige. Det kan føre til store vedlikeholdsproblemer; hvis teammedlemmer ikke vet at deler av koden er KI-generert, kan det bli ekstremt vanskelig å forstå og vedlikeholde den. Det skaper også en skjult risiko for potensielle juridiske konflikter relatert til opphavsrett, dersom KI-en har generert kode som bryter med lisenser.

### 5.3 Påvirkning på læring og kompetanse

**Hvordan påvirker KI-avhengighet fremtidig kompetanse?**
Vår erfaring har tydelig vist at en høy grad av avhengighet til KI, som vi opplevde i prosjektet, forskyver læringsfokuset. Vår læring ble, som nevnt, mer konsentrert om "verktøybruk og prosjektgjennomføring enn på dypere kodekonsepter." Dette kan potensielt føre til en mer overfladisk kompetanse, hvor man blir dyktig til å benytte KI-verktøy for å oppnå resultater, men mangler en solid grunnforståelse av fundamentale prinsipper innen algoritmer, datastrukturer eller designmønstre. På sikt kan dette begrense evnen til å innovasere selvstendig eller feilsøke komplekse problemer der KI ikke har en umiddelbar løsning.

**Hvilke ferdigheter risikerer man å ikke utvikle?**
Ved å delegere mye av det kognitive arbeidet til KI, risikerer man å ikke utvikle en rekke kritiske ferdigheter:
-   **Fundamentale problemløsningsevner:** Den uavhengige analytiske tenkningen som kreves for å bryte ned og løse problemer fra bunnen av.
-   **Dyp kodeforståelse:** Evnen til å forstå *hvorfor* koden fungerer, ikke bare *at* den fungerer, inkludert dypere innsikt i kompilatorfeil, minnebehandling og ytelsesoptimalisering.
-   **Feilsøking av komplekse systemer:** Selv om KI kan hjelpe med enkle feil, krever komplekse, systemiske feil fortsatt dyptgående menneskelig analyse.
-   **Algoritmisk tenkning:** Evnen til å designe og implementere effektive algoritmer selv.
-   **Kreativ arkitekturdesign:** KI tenderer til å gi standardløsninger, mens menneskelig kreativitet er nødvendig for å utvikle nye og innovative arkitekturer.

**Balanse mellom effektivitet og læring**
Dette var et sentralt dilemma i vårt prosjekt. Vi valgte å prioritere effektivitet og prosjektgjennomføring på grunn av tids- og forståelsesbegrensninger. For studenter er det en avgjørende balanse å finne:
-   KI kan effektivt brukes for å komme i gang eller generere boilerplate-kode, men for å maksimere læringen er det essensielt å *aktivt forsøke å forstå, analysere og modifisere* den KI-genererte koden.
-   KI bør fungere som et læringsverktøy og en assistent, ikke en erstatning for egen tankevirksomhet og innsats for å bygge dyp teknisk forståelse.

### 5.4 Arbeidsmarkedet

**Hvordan kan utbredt KI-bruk påvirke fremtidige jobber i IT?**
Utbredt KI-bruk vil fundamentalt endre IT-arbeidsmarkedet. Vi ser for oss to hovedtrender:
-   **Automatisering av rutineoppgaver:** KI kan automatisere repetitiv og standardisert koding, samt enklere feilsøking. Dette vil frigjøre utviklere til mer komplekse, kreative og strategiske oppgaver.
-   **Økt produktivitet og effektivisering:** Utviklere som effektivt utnytter KI-verktøy vil kunne levere mer på kortere tid. Dette kan potensielt redusere behovet for et stort antall utviklere til visse prosjekttyper, men vil samtidig øke verdien av de som mestrer KI-assistert utvikling.
-   **Skifte i kompetansebehov:** Fokuset vil flyttes fra ren kodeevne til ferdigheter som prompt engineering, kritisk evaluering av KI-output, forståelse av systemarkitektur, og menneskesentrerte ferdigheter som kommunikasjon og samarbeid.

**Hvilke roller vil bli viktigere/mindre viktige?**
-   **Viktigere roller:** Roller som fokuserer på overordnet systemdesign, arkitektur, AI-strategi, prompt engineering, etisk AI-utvikling, og "human in the loop"-rollen der menneskelig dømmekraft er kritisk. Tverrfaglige ferdigheter, hvor man kombinerer AI-kompetanse med dyp domenekunnskap, vil også bli svært verdifulle.
-   **Mindre viktige roller:** Rent junior-nivå koderoller som primært involverer å skrive standardisert kode, eller roller fokusert utelukkende på repetitive kodeoppgaver som KI enkelt kan håndtere, vil sannsynligvis bli mindre etterspurt eller transformert.

**Deres refleksjoner om fremtidig karriere i en KI-drevet verden**
Våre refleksjoner tilsier at **tilpasningsevne** er nøkkelen. Evnen til kontinuerlig å lære og integrere nye KI-verktøy og metoder i arbeidsflyten vil være avgjørende for enhver IT-profesjonell. Verdien vil forskyves fra å kunne skrive *hver eneste kodelinje* til å kunne *effektivt utnytte KI for å produsere kvalitetskode og løsninger*, samtidig som man opprettholder et kritisk perspektiv. Det blir viktig å kultivere "ikke-automatiserbare" ferdigheter som kreativitet, kritisk tenkning, kompleks problemløsning, etiske vurderinger og mellommenneskelig interaksjon, da disse vil være vanskelige for KI å erstatte.

### 5.5 Datasikkerhet og personvern

**Hvilke data delte dere med KI-verktøy?**
-   **Oppgavebeskrivelser:** Kjernen i prosjektet vårt var å sende brukerskrevne oppgavetitler til Gemini for analyse. Dette innebærer en deling av potensielt personlig identifiserbar informasjon (PII), avhengig av hva brukeren skriver.
-   **Prosjektdokumenter:** Vi delte hele prosjektkonteksten med Gemini CLI, inkludert dokumenter som `proposal.md`, `project-plan.md` og `architecture.md`.
-   **Kodebiter og hele filer:** Underveis i utviklingen delte vi sannsynligvis både enkeltstående kodebiter og hele kodefiler for å få hjelp til feilsøking og generering av ny kode.
-   **API-nøkler:** Selv om vi ikke delte API-nøkler direkte i prompts, utviklet vi kode som håndterer disse nøklene med KI-assistanse, noe som utgjør en indirekte eksponering.

**Potensielle risikoer ved å dele kode og data med KI**
-   **Konfidensialitet og personvern:** Deling av oppgavebeskrivelser og annen data kan utgjøre en risiko for at sensitiv informasjon blir brukt til å trene fremtidige modeller eller blir eksponert i en eventuell datalekkasje.
-   **Sikkerhetssårbarheter:** KI-generert kode er ikke garantert sikker. Den kan inneholde sårbarheter som, hvis de ikke blir oppdaget, kan utnyttes i den ferdige applikasjonen.
-   **Tap av intellektuell eiendom:** For et kommersielt prosjekt ville deling av proprietær kode eller forretningslogikk med en ekstern KI-tjeneste utgjort en betydelig risiko for tap av konkurransefortrinn.

**Hvordan skal man tenke på sikkerhet når man bruker KI?**
Vår erfaring og refleksjon har ført til følgende sikkerhetsprinsipper:
-   **Anta at alt er offentlig:** Man bør behandle all data som deles med en offentlig KI-modell som om den var offentlig tilgjengelig. Dette betyr at man aldri må dele sensitiv, proprietær eller personlig identifiserbar informasjon.
-   **Valider all KI-output:** All kode generert av KI må gjennomgås og testes grundig for sikkerhetssårbarheter, på lik linje med kode fra et hvilket som helst eksternt bibliotek.
-   **Bruk private/lokale modeller for sensitiv data:** For prosjekter med høy sensitivitet, bør man vurdere å bruke KI-modeller som kan hostes privat, slik at ingen data forlater egen infrastruktur.
-   **Forstå bruksvilkårene:** Det er avgjørende å lese og forstå hvordan KI-leverandøren håndterer datalagring, personvern og sikkerhet, for å kunne ta en informert risikovurdering.

---

## 6. Teknologiske implikasjoner

### 6.1 Kodekvalitet og vedlikehold

**Hvordan påvirker KI-generert kode langsiktig vedlikehold?**
KI-generert kode har en todelt innvirkning på langsiktig vedlikehold. På den ene siden kan den introdusere standardiserte mønstre og robuste løsninger, spesielt for boilerplate-kode, noe som potensielt kan *forenkle* fremtidig vedlikehold. På den annen side kan utfordringene med vedlikehold være betydelige dersom:
-   **Inkonsekvent stil og mønstre:** Uten klare instruksjoner kan KI generere kode med varierende stil og implementeringsmønstre, noe som gjør kodbasen vanskeligere å navigere i og vedlikeholde over tid.
-   **Mangel på klar intensjon:** KI-generert kode mangler ofte den dypere konteksten, rasjonalet eller "hvorfor"-et bak implementeringsvalgene, som menneskeskrevet kode normalt har (enten gjennom kommentarer, dokumentasjon, eller underforstått kunnskap hos forfatteren). Dette gjør det vanskelig å forstå og endre koden senere.
-   **Avhengighet av KI for endringer:** Hvis den opprinnelige utvikleren ikke fullt ut forsto den KI-genererte koden, kan fremtidige modifikasjoner kreve at man igjen engasjerer KI-en, noe som skaper en ny type avhengighet.

**Er KI-kode like forståelig som menneskeskrevet kode?**
Generelt er KI-generert kode *mindre forståelig* enn kode skrevet av mennesker som har full kontekst. Dette er spesielt sant hvis koden er generert i "YOLO-modus" eller uten grundig menneskelig gjennomgang. Selv om KI kan produsere syntaktisk korrekt og til tider optimalisert kode, mangler den den menneskelige intensjonen og historikken som gjør kode enklere å forstå. Vår grunnere forståelse av kodingen, på grunn av KI-avhengigheten, bidro også til at den KI-genererte koden ble mindre transparent for oss.

**Utfordringer med å debugge KI-generert kode**
Feilsøking av KI-generert kode byr på spesifikke utfordringer:
-   **Mangel på mental modell:** Det er vanskeligere å feilsøke kode når man ikke har en klar mental modell av hvordan koden *skal* fungere, og hvorfor spesifikke designvalg ble tatt.
-   **Uventede kanttilfeller:** KI er ikke alltid like god til å forutse alle tenkelige kanttilfeller. Å identifisere og rette opp slike i KI-generert kode kan være tidkrevende dersom logikken ikke er transparent eller om vi ikke fullt ut forstår den underliggende implementasjonen.
-   **"Magisk" kode:** Noen KI-genererte løsninger kan fremstå som "magi" hvis utvikleren ikke forstår de underliggende prinsippene, noe som gjør feilsøking vanskelig og ofte tidkrevende.

### 6.2 Standarder og beste praksis

**Følger KI alltid beste praksis og industristandarder?**
Generelt sett er KI-modeller trent på et enormt korpus av kode som ofte følger etablerte beste praksis og industristandarder. Derfor kan KI generere kode som er i tråd med slike standarder. Imidlertid er dette ikke alltid tilfellet. Vår erfaring indikerte at KI også kan produsere utdatert, suboptimale, eller inkonsekvente løsninger som ikke alltid samsvarer med prosjektets spesifikke konvensjoner eller de mest moderne praksisene. Episoden med "YOLO-modus" bekrefter dette; dersom beste praksis ble konsekvent fulgt, ville behovet for etterfølgende feilretting vært minimalt. Utfordringen med at KI ikke gjenkjente nye filstier, peker også på en mangel i KI-ens "beste praksis" for dynamisk prosjektledelse.

**Eksempler på hvor KI foreslo utdaterte eller dårlige løsninger**
Selv om vi ikke eksplisitt identifiserte spesifikke utdaterte løsninger, impliserte vår bruk av "YOLO-modus" og de påfølgende manuelle korreksjonene at KI-en produserte løsninger som avvek fra det vi anså som "god" eller "beste" praksis for prosjektet. Dette kunne for eksempel manifestere seg som mer omstendelig kode enn nødvendig, mindre effektive implementeringer, eller bruk av Flask/Python-mønstre som ikke var idiomatiske for den ønskede versjonen av applikasjonen.

**Viktigheten av å validere KI sine forslag**
Vår viktigste lærdom er den absolutte nødvendigheten av å validere KI-ens forslag. Erfaringene med å korrigere feil fra "YOLO-modus" og å manuelt veilede KI-en om filstier, understreker at KI er en kraftig assistent, men dens output må behandles som et forslag – ikke en definitiv løsning. Validering er avgjørende for å sikre:
    -   **Korrekthet:** At koden faktisk gjør det den skal.
    -   **Sikkerhet:** At det ikke introduseres sårbarheter.
    -   **Ytelse:** At løsningen er effektiv.
    -   **Overholdelse av standarder:** At koden følger prosjektets etablerte beste praksis og stilguider.

### 6.3 Fremtidig utvikling

**Hvordan tror dere KI vil påvirke programvareutvikling fremover?**
Vi tror at KI vil transformere programvareutviklingen på flere grunnleggende måter:
-   **Økt automatisering:** Stadig flere oppgaver, fra kodegenerering og refaktorering til testing og delvis utrulling, vil bli automatisert av KI. Dette vil endre utviklerens rolle fra hovedsakelig å skrive kode til å styre og orkestrere KI-verktøy.
-   **Forskyvning mot høyere abstraksjonsnivåer:** Utviklere vil i større grad arbeide med abstrakte spesifikasjoner, designprinsipper og KI-modeller, snarere enn lavnivå kode. Fokus blir å definere problemet og validere løsningen, mens KI håndterer mye av implementeringsdetaljene.
-   **KI som en allestedsnærværende assistent:** KI vil bli en integrert og uunnværlig del av utviklingsmiljøet, og tilbyr sanntidsforslag, kodeforbedringer, feilsøkingshjelp og kontekstuell veiledning.
-   **Fokus på integrasjon og orkestrering:** Rollen med å koble sammen ulike KI-verktøy, systemer og menneskelig innsats for å skape helhetlige løsninger vil bli mer sentral.

**Hvilke ferdigheter blir viktigere for utviklere?**
I en KI-drevet fremtid vil visse ferdigheter bli mer kritiske enn andre:
-   **Kritisk tenkning og validering:** Evnen til å kritisk evaluere KI-generert output for korrekthet, effektivitet og sikkerhet blir essensiell.
-   **Problemdekomponering:** Ferdigheten til å bryte ned komplekse problemer i mindre, håndterbare oppgaver som KI-en kan bistå med.
-   **Prompt Engineering:** Evnen til å effektivt kommunisere med KI-modeller for å oppnå ønskede resultater.
-   **Arkitekturdesign og systemforståelse:** En dyp forståelse av systemarkitektur og hvordan ulike komponenter interagerer, blir viktigere for å kunne veilede KI.
-   **Domenekompetanse:** Dyp kunnskap om problemområdet for å kunne stille de riktige spørsmålene til KI-en og validere løsningene.
-   **Menneskesentrerte ferdigheter:** Samarbeid, kommunikasjon, lederskap og etisk resonnement vil være uerstattelige.

**Deres anbefalinger for hvordan man bør bruke KI i utviklingsprosesser**
Basert på våre erfaringer anbefaler vi følgende for fremtidig bruk av KI i utviklingsprosesser:
-   **Bruk KI som en intelligent assistent, ikke en erstatning:** KI bør forsterke menneskelig intelligens og innsats, ikke erstatte den.
-   **Oppretthold alltid "human in the loop":** Menneskelig overvåking og gjennomgang av KI-generert kode er fundamentalt for kvalitet, sikkerhet og vedlikehold.
-   **Fokusér på læring:** Bruk KI-output som en læringsmulighet. Prøv å forstå den genererte koden, lær av den, og refaktorer den til tider for å dype forståelsen.
-   **Vær bevisst på KI-ens begrensninger:** Forstå hva KI er god på og hvor den kommer til kort (f.eks. dyp kontekst, kreativitet i nye domener, etiske vurderinger).
-   **Prioriter etiske og sikkerhetsmessige hensyn:** Alltid tenk på personvern, datasikkerhet og potensielle skjevheter i KI-genererte løsninger.

---

## 7. Konklusjon og læring

### 7.1 Viktigste lærdommer

1.  **KI som en kraftfull muliggjører i utfordrende situasjoner:** KI gjorde det mulig å fullføre et komplekst prosjekt til tross for utfordringer med timeplaner, samarbeid og manglende dyp forståelse av enkelte tekniske konsepter. Uten KI hadde prosjektgjennomføringen vært langt vanskeligere, og kanskje umulig innenfor gitte rammer.
2.  **Den kritiske betydningen av "human in the loop" og validering:** Til tross for KI-ens evner er outputen ikke feilfri. Erfaringer med "YOLO-modus" og problemer med filstier understreket det absolutte behovet for menneskelig tilsyn, kritisk gjennomgang og manuell korrigering for å sikre kvalitet og korrekthet. KI er en assistent, ikke en erstatning for menneskelig dømmekraft.
3.  **Avveiningen mellom effektivitet og dyp læring:** KI økte produktiviteten og prosjektgjennomføringen betydelig. Denne effektiviteten kom imidlertid på bekostning av en grunnere forståelse av kjernekonsepter innen koding og mindre utvikling av uavhengige problemløsningsevner.
4.  **Tilpasningsevne og verktøykompetanse er fremtidens nøkkelferdigheter:** Prosjektet fremhevet den økende viktigheten av å lære å effektivt bruke KI-verktøy (som Gemini CLI og VS Code) og tilpasse seg nye arbeidsmetoder, fremfor kun å fokusere på ren kodeevne.
5.  **Etiske og praktiske implikasjoner av KI-bruk:** Prosjektet tvang oss til å reflektere over ansvar, transparens, datasikkerhet og KI-ens innvirkning på egen læring og fremtidig karriere, noe som er avgjørende i en KI-drevet verden.

### 7.2 Hva ville dere gjort annerledes?
 Refleksjon over hva vi ville gjort annerledes dersom vi skulle startet på nytt, gir verdifull innsikt:

- **Tekniske valg:**
    -   **Database:** Gitt utfordringene med enkelheten til SQLite i en webserver-kontekst, ville vi vurdert et mer robust databasesystem som PostgreSQL fra starten, selv for en MVP, for å bedre håndtere skalerbarhet og samtidige operasjoner.
    -   **Frontend-rammeverk:** For å adressere kompleksiteten knyttet til frontend state management, ville vi vurdert et moderne JavaScript-rammeverk som React eller Vue.js, som tilbyr mer elegante løsninger for interaktive brukergrensesnitt enn vanilla JS og Jinja2.
- **Bruk av KI:**
    -   **Mindre "YOLO-modus":** Vi ville innført strengere rutiner for validering og testing av KI-generert kode, og unngått "YOLO-modus" for å minimere behovet for omfattende etterarbeid.
    -   **Mer eksplisitt prompt engineering for struktur og standarder:** Vi ville gitt KI-en tydeligere og mer detaljerte instruksjoner angående kodestandarder, filorganisering og arkitektoniske mønstre for å redusere inkonsekvenser og bedre tilpasse output til prosjektets behov.
    -   **Fokus på forståelse av generert kode:** Vi ville aktivt satt av mer tid til å forstå *hvordan* KI-en løste et problem, i stedet for kun å benytte dens output. KI-en ville blitt brukt som et verktøy for å akselerere læring, ikke erstatte den.
    -   **Bedre filsti-håndtering:** Utviklet en klarere strategi for hvordan KI interagerer med dynamiske filstrukturer, potensielt ved eksplisitt å oppdatere KI-ens kunnskapsbase om filplasseringer, eller ved å etablere faste lokasjoner for delte filer.
- **Samarbeid og organisering:**
    -   **Mer strukturerte sjekk-ins:** Til tross for utfordringer med timeplaner, ville mer formelle, korte daglige eller asynkrone stand-ups ha forbedret koordineringen og sikret en mer jevn progresjon.
    -   **Klarere oppgavefordeling:** Definert oppgaver enda mer granulært og eksplisitt tildelt eierskap for å unngå dobbeltarbeid eller misforståelser.
    -   **Proaktiv kommunikasjon:** Selv med KI-assistanse, ville vi prioritert proaktiv kommunikasjon rundt kritiske beslutninger og blokkeringer for å sikre at alle var informert og kunne bidra til løsninger.

### 7.3 Anbefalinger

- **Råd om effektiv bruk av KI:**
    -   **Bruk KI som en kraftfull assistent, ikke en erstatning:** Utnytt KI for boilerplate-kode, komplekse logiske utfordringer, dokumentasjon og som et læringsverktøy, men behold alltid menneskelig overvåking. KI skal forsterke, ikke erstatte, menneskelig intelligens og innsats.
    -   **Mestre prompt engineering:** Lær å formulere klare, konsise og strukturerte instruksjoner til KI-en for å oppnå de beste og mest relevante resultatene. En god prompt er nøkkelen til god output.
    -   **Fokus på problemdekomponering:** Bryt ned komplekse problemer i mindre, håndterbare deler som KI-en effektivt kan bistå med, og deretter integrer delene selv.
    -   **Iterativ bruk:** Engasjer KI i en iterativ prosess: start med en prompt, vurder resultatet, raffiner og tilpass, og gi deretter nye prompter.

- **Fallgruver å unngå:**
    -   **"YOLO-modus":** Unngå blind aksept av KI-output. Dette kan føre til feil, sikkerhetshull og kode som er vanskelig å vedlikeholde. Alltid kritisk gjennomgå og test KI-generert kode.
    -   **Overdreven avhengighet som fører til grunn læring:** Pass på at KI-bruk komplementerer, heller enn erstatter, utviklingen av fundamental kompetanse og dyp teknisk forståelse. Sett av tid til å forstå *hvorfor* KI-en foreslår visse løsninger.
    -   **Ignorering av kontekst og standarder:** KI-generert kode må alltid tilpasses prosjektets spesifikke konvensjoner, stilguider og bredere beste praksis for å sikre en enhetlig og vedlikeholdbar kodebase.
    -   **Undervurdering av feilsøkingsutfordringer:** Vær forberedt på at feilsøking av KI-generert kode kan være mer utfordrende dersom den underliggende logikken ikke er fullt forstått.
    -   **Risiko for databeskyttelse og sikkerhet:** Vær ekstremt forsiktig med å dele sensitiv eller proprietær data med offentlige KI-modeller. Anta at alt du deler kan bli offentlig.

- **Beste praksis dere oppdaget:**
    -   **Aktiv menneskelig validering:** Den viktigste praksisen er å alltid kritisk gjennomgå, teste og forstå KI-generert kode før den implementeres.
    -   **Klar dokumentasjon av KI-bruk:** Dokumenter prompts, generert kode og begrunnelser for valg som er tatt basert på KI-input. Dette sikrer transparens og etterrettelighet.
    -   **Strategisk promptdesign:** Invester tid i å utforme prompter som ikke bare ber om kode, men som også styrer KI-en mot ønskede stiler, arkitekturer og løsningsprinsipper.
    -   **Utnytte KI for diverse oppgaver:** Bruk KI utover bare koding – til dokumentasjon, idédugnad, læring, og som assistent i kodeanmeldelser.

### 7.4 Felles refleksjon
Når vi ser tilbake på dette semesteret, må vi være ærlige på at faget har vært en større utfordring enn vi forutså. Til tross for en grei innsats har vi opplevd læringskurven som bratt, og vi har alle kjent på at faget har vært vanskelig å gripe an. I ettertid ser vi tydelig at totalbelastningen ble for stor; kombinasjonen av dette krevende emnet parallelt med tre andre fag, samt jobb og forpliktelser i privatlivet, gjorde at vi nok tok oss vann over hodet denne perioden. Vi er enige om at forutsetningene for læring ikke var optimale, og hadde vi hatt færre ytre begrensninger og mer tid til dedikert fordypning, er vi overbevist om at vi ville sittet igjen med en langt bedre mestringsfølelse og dypere faglig forståelse.

Til tross for motbakkene har vi satt stor pris på læreren, som har vært svært dyktig på veiledning og en god støtte når vi har stått fast. Faget inneholder mange komplekse begreper og konsepter som vi fortsatt synes er utfordrende. Vi har derfor valgt å benytte kunstig intelligens som et aktivt hjelpemiddel i utformingen av denne refleksjonsrapporten, for å sikre at vi klarer å formulere oss presist og knytte de rette begrepene til våre erfaringer. Det betyr imidlertid ikke at vi står igjen uten utbytte. Tvert imot har prosessen vært både gøy og spennende, og vi verdsetter spesielt at vi har fått praktisk erfaring med moderne utviklerverktøy. Å lære seg å bruke VS Code og integrere KI-hjelp i et faktisk prosjekt er kompetanse vi tar med oss videre.

---

## 8. Vedlegg

- https://github.com/IBE160/SG-612

---

**Ordantall:** 6270
