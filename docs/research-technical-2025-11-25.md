# Technical Research Report: Flask Application Folder Structure Best Practices

**Generated Date:** 2025-11-25
**Project:** ibe160 (University Course, Proof-of-Concept)
**User Skill Level:** Beginner
**Generated by:** Analyst Agent

---

## 1. Executive Summary

This report outlines best practices for structuring a Python Flask application for a medium-sized university proof-of-concept project. The primary goal was to identify a folder structure that supports modularity, maintainability, scalability, and testability, while integrating Flask Blueprints, SQLAlchemy with SQLite, Pytest, `python-dotenv` for configuration, and Bootstrap 5 for the frontend. The recommended structure is the **Standard Modular Structure**, which provides a clear separation of concerns and robust support for the specified technologies, offering a balance of simplicity and professional best practices.

---

## 2. Requirements and Constraints

### Functional Requirements

*   The application will be a To-Do list.
*   It will integrate with the Gemini AI.
*   It will be structured using modular components (Blueprints).

### Non-Functional Requirements

*   **Maintainability**: The structure must be easy to understand and modify.
*   **Scalability**: The structure must easily accommodate new features and Blueprints.
*   **Testability**: The structure must be compatible with Pytest for easy, independent testing of components.

### Technical Constraints

*   **Backend**: Python, Flask, SQLAlchemy.
*   **Database**: SQLite.
*   **Frontend**: Bootstrap 5 (requiring `static/` and `templates/` folders).
*   **Testing**: Pytest.
*   **Configuration**: Secure API key management using a library like `python-dotenv`.

---

## 3. Technology Options (Folder Structure Patterns)

Two primary folder structure patterns were considered:

### Option 1: Standard Modular Structure

This pattern groups files by their *type* (e.g., all models in one file/directory, all routes in another).

```
/project_root
├── .env
├── instance/
├── migrations/
├── tests/
├── venv/
├── app/
│   ├── __init__.py        # Contains the application factory
│   ├── config.py          # Configuration settings
│   ├── models.py          # All SQLAlchemy models
│   ├── extensions.py      # Extension initialization (SQLAlchemy)
│   ├── cli.py             # Custom Flask CLI commands
│   ├── main/ (Blueprint)
│   ├── todos/ (Blueprint)
│   ├── auth/ (Blueprint)
│   ├── static/
│   └── templates/
├── wsgi.py
├── requirements.txt
└── README.md
```

### Option 2: Feature-Based (or "Component") Structure

This pattern groups files by the *feature* they belong to, with each feature containing its own routes, models, and templates.

```
/project_root
├── .env
├── migrations/
├── tests/
├── venv/
├── app/
│   ├── __init__.py
│   ├── config.py
│   ├── common/
│   ├── features/
│   │   ├── todos/ (Feature)
│   │   └── auth/ (Feature)
│   ├── static/
│   └── templates/
├── wsgi.py
├── requirements.txt
└── README.md
```

---

## 4. Detailed Profile: Standard Modular Structure (Chosen Option)

The **Standard Modular Structure** was chosen as the recommended approach. This structure provides a clear, understandable, and maintainable project layout that is well-suited for a medium-sized Flask application.

```
my_flask_app/
├── .env                  # Environment variables (Gemini API key, database URL, etc.)
├── instance/             # Instance folder (ignored by git, for instance-specific config)
│   └── config.py         # Production/instance-specific configuration
├── migrations/           # Database migration scripts (Alembic/Flask-Migrate)
├── tests/                # Your Pytest tests
│   ├── __init__.py       # Makes tests/ a Python package
│   ├── conftest.py       # Pytest fixtures and configurations
│   ├── unit/             # Unit tests for models, utilities
│   │   └── test_models.py
│   └── functional/       # Functional/integration tests for blueprints
│       └── test_todos.py
├── venv/                 # Python virtual environment
├── app/                  # The core application package
│   ├── __init__.py       # Application factory, extension initialization, blueprint registration
│   ├── config.py         # Base and environment-specific configurations
│   ├── models.py         # SQLAlchemy database models
│   ├── extensions.py     # Initialize Flask extensions (SQLAlchemy, Migrate, Login, etc.)
│   ├── cli.py            # Custom Flask CLI commands
│   ├── main/             # Main blueprint (e.g., for homepage, general error pages)
│   │   ├── __init__.py   # Blueprint definition
│   │   ├── routes.py     # View functions for the main blueprint
│   │   └── forms.py      # Forms for the main blueprint
│   ├── todos/            # To-Do list blueprint
│   │   ├── __init__.py   # Blueprint definition
│   │   ├── routes.py     # View functions for todos
│   │   ├── forms.py      # Forms for todos
│   │   └── services.py   # Business logic (e.g., AI integration calls)
│   ├── auth/             # Authentication blueprint (example)
│   │   ├── __init__.py
│   │   ├── routes.py
│   │   ├── forms.py
│   │   └── models.py     # Models specific to auth (if not in app/models.py)
│   ├── static/           # Static assets (CSS, JS, images) for the entire app
│   │   ├── css/
│   │   │   └── bootstrap.min.css # Your Bootstrap CSS
│   │   └── js/
│   │       └── bootstrap.bundle.min.js # Your Bootstrap JS
│   └── templates/        # Jinja2 HTML templates for the entire app
│       ├── base.html     # Base layout template
│       ├── _macros.html  # Reusable template macros
│       ├── main/         # Templates specific to the main blueprint
│       │   └── index.html
│       ├── todos/        # Templates specific to the todos blueprint
│       │   ├── list.html
│       │   └── create.html
│       └── auth/         # Templates specific to the auth blueprint
│           └── login.html
├── wsgi.py               # Entry point for production WSGI servers
├── requirements.txt      # Project dependencies
└── README.md             # Project documentation
```

**Explanation of Key Elements:**

*   **Application Factory (`app/__init__.py`)**: Centralizes application creation, extension initialization, and Blueprint registration, facilitating testing and flexible configurations.
*   **Blueprints (`app/main`, `app/todos`, `app/auth`)**: Each blueprint encapsulates a feature area, containing its own routes, forms, and templates. This modular approach keeps code organized and allows for independent development and testing of features.
*   **`models.py`**: A central location for all SQLAlchemy database models, ensuring a single source of truth for the database schema.
*   **`extensions.py`**: Dedicated for initializing Flask extensions, making them readily available across the application.
*   **`static/` & `templates/`**: Global directories for frontend assets and base HTML templates, with Blueprint-specific subdirectories for component-specific assets.
*   **`tests/`**: Structured with `conftest.py` for Pytest fixtures and subdirectories for unit and functional tests, ensuring comprehensive test coverage.
*   **`.env` and `instance/config.py`**: Provide a robust system for managing environment-specific configurations and securing sensitive data like API keys.

---

## 5. Comparative Analysis

Not applicable. After presenting two viable options, the user opted for the Standard Modular Structure, making a direct comparison between multiple chosen options unnecessary.

---

## 6. Trade-off Analysis

Not applicable. As a single preferred option was selected, a detailed trade-off analysis between alternatives was not required. The benefits and minor drawbacks of the chosen structure were covered in its detailed profile.

---

## 7. Use Case Fit Analysis

The Standard Modular Structure aligns perfectly with the project's use case:
*   **Medium-sized University Project**: The structure is easy to grasp for learning purposes while introducing professional organizational principles.
*   **Modular with Blueprints**: Explicitly supports the desired modularity, allowing the To-Do list and AI integration to be developed as distinct components.
*   **Professional Best Practices**: Incorporates key Flask patterns (Application Factory, Blueprints) and best practices for configuration, testing, and database management.

---

## 8. Real-World Evidence

The recommended structure is a widely adopted and well-regarded pattern in the Flask community, supported by numerous tutorials, official documentation, and real-world applications. Its effectiveness is proven in projects aiming for maintainability and scalability through modularity.

---

## 9. Recommendations

**Top Recommendation:**

*   **Adopt the Standard Modular Structure** for your Flask project, as detailed in Section 4.

**Rationale:**

*   This structure provides the best balance of professional best practices, maintainability, and simplicity for your medium-sized university project. It directly supports all your stated requirements, including the use of Blueprints, SQLAlchemy, Pytest, and secure configuration management.

**Implementation Roadmap:**

1.  **Initial Setup**: Create the main folder structure (`app/`, `tests/`, `migrations/`, `.env`).
2.  **Application Factory**: Implement the `create_app()` function in `app/__init__.py`. Initialize Flask extensions (`SQLAlchemy`, `Migrate`) within it.
3.  **First Blueprint**: Create your first Blueprint (e.g., for the `todos` feature) in a dedicated `app/todos/` directory and register it in `create_app()`.
4.  **Models**: Define your SQLAlchemy models in `app/models.py`.
5.  **Testing**: Set up your Pytest fixtures in `tests/conftest.py` to create a test application instance.

---

## 10. Architecture Decision Record

```markdown
# ADR-001: Flask Application Folder Structure

## Status

Accepted

## Context

We are building a new, medium-sized Flask application for a university project. The application is a To-Do list with AI (Gemini) integration. Key requirements include using Flask Blueprints for modularity, SQLAlchemy for the database, Pytest for testing, Bootstrap 5 for the frontend, and `python-dotenv` for secure configuration. The goal is to follow professional best practices suitable for a learning project that needs to be scalable and maintainable.

## Decision

We will adopt the **Standard Modular Structure**. This pattern organizes the project by file type (e.g., models, routes, templates) within a core `app` package. It utilizes an application factory (`create_app`) for initialization and Flask Blueprints to encapsulate feature-specific routes and templates into their own subdirectories (e.g., `app/todos/`, `app/auth/`).

## Consequences

**Positive:**
*   **Clarity:** The structure is well-documented and widely understood in the Flask community, making it easy to follow.
*   **Maintainability:** Separation of concerns is clear. For example, all database models are in `app/models.py`, and all application configurations are in `app/config.py`.
*   **Testability:** The layout is conducive to testing with Pytest, allowing for clear separation of unit and functional tests and easy setup of test fixtures.
*   **Modularity:** Blueprints provide a clean way to organize features, preventing the main application file from becoming monolithic.

**Negative:**
*   For very large applications, working on a single feature might require navigating between multiple directories (e.g., `models/`, `blueprints/`, `templates/`). This is a minor concern for the current project scope.

**Neutral:**
*   This structure encourages good habits that are transferable to larger, more complex projects.

## References

*   Flask Application Factory Pattern
*   Flask Blueprints Documentation
```
