<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>2.3</storyId>
    <title>Rule-Based Fallback Mechanism</title>
    <status>drafted</status>
    <generatedAt>2025-12-01</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/2-3-rule-based-fallback-mechanism.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a developer</asA>
    <iWant>to implement a rule-based fallback mechanism</iWant>
    <soThat>the application can still suggest labels and priorities if the AI service is unavailable</soThat>
    <tasks>
*   **1. AI Service Implementation (`ai_service.py`):**
    *   [ ] In the `get_ai_suggestions` function, add error handling (e.g., a `try...except` block) around the Gemini API call.
    *   [ ] In the `except` block, implement the rule-based fallback logic.
    *   [ ] The logic should check for keywords in the task title and return a corresponding label and priority.
    *   [ ] Implement the default suggestion ("Other", "Low") if no keywords match.
*   **2. Frontend Implementation (templates/index.html & custom JS):**
    *   [ ] Modify the JavaScript function that calls `/api/suggest` to handle a new flag in the response (e.g., `{"fallback": true}`).
    *   [ ] If the `fallback` flag is true, trigger a toast notification with the message "AI unavailable, used fallback suggestions."
*   **3. Backend API Endpoint (app.py):**
    *   [ ] Modify the `/api/suggest` endpoint to include the `fallback` flag in its response if the AI service indicates that the fallback was used.
*   **4. Verification & Testing:**
    *   [ ] **Unit Test**: Write a unit test for the `get_ai_suggestions` function in `ai_service.py` that specifically tests the fallback logic by mocking a failed API call.
    *   [ ] **Integration Test**: Write a test for the `/api/suggest` endpoint that simulates a failure in the `ai_service` and verifies that the endpoint returns the fallback suggestions with the `fallback: true` flag.
    *   [ ] **E2E Test**: Write a test using Playwright that mocks the `/api/suggest` endpoint to return a fallback response, and verifies that the toast notification appears on the UI.
    </tasks>
  </story>

  <acceptanceCriteria>
1.  **AC1**: Given the AI service call fails (e.g., returns an error, times out, or provides a malformed response), the `ai_service.py` module triggers the internal fallback mechanism.
2.  **AC2**: The fallback mechanism uses keyword matching against the task title to suggest a `label` and `priority`.
3.  **AC3**: If no keywords match, the fallback defaults to suggesting "Other" for the label and "Low" for the priority.
4.  **AC4**: The frontend UI provides a subtle, non-blocking notification (e.g., a toast) to the user indicating that fallback suggestions were used (e.g., "AI unavailable, used fallback suggestions").
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/fase-3-solutioning/architecture.md</path>
        <title>Architecture</title>
        <section>Novel Pattern Designs: AI-Suggestion Flow (Magic Fill) - Edge Cases and Fallback Mechanism</section>
        <snippet>This section details the triggers for the fallback mechanism and the keyword-based logic to be used.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-2.md</path>
        <title>Epic Technical Specification: AI-Powered Task Intelligence</title>
        <section>Workflows and Sequencing: AI-Suggestion Flow ("Magic Fill")</section>
        <snippet>This section describes when the fallback mechanism is triggered within the overall AI suggestion workflow.</snippet>
      </doc>
      <doc>
        <path>docs/fase-2-planning/prd.md</path>
        <title>Product Requirements Document</title>
        <section>Functional Requirements: FR11</section>
        <snippet>FR11: The system provides a rule-based fallback for label and priority suggestions if the AI service is unavailable or exceeds quota.</snippet>
      </doc>
    </docs>
    <code>
      <file>
        <path>ai_service.py</path>
        <kind>service</kind>
        <symbol>get_ai_suggestions</symbol>
        <reason>The fallback logic will be implemented within this function.</reason>
      </file>
      <file>
        <path>app.py</path>
        <kind>controller</kind>
        <symbol>/api/suggest</symbol>
        <reason>This endpoint will be modified to include a 'fallback' flag in its response.</reason>
      </file>
      <file>
        <path>templates/index.html</path>
        <kind>view</kind>
        <symbol>Toast notification</symbol>
        <reason>The UI will be updated to display a notification when the fallback is used.</reason>
      </file>
    </code>
    <dependencies>
      <ecosystem>
        <name>Node.js</name>
        <manifest>package.json</manifest>
        <packages>
          <package name="@faker-js/faker" version="8.4.1" />
          <package name="@playwright/test" version="1.57.0" />
          <package name="@types/node" version="^24.10.1" />
          <package name="autoprefixer" version="^10.4.22" />
          <package name="postcss" version="^8.5.6" />
          <package name="tailwindcss" version="^4.1.17" />
        </packages>
      </ecosystem>
      <ecosystem>
        <name>Python</name>
        <manifest>requirements.txt</manifest>
        <packages>
            <!-- requirements.txt not found -->
        </packages>
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
    - The fallback logic should be simple and fast, not adding significant latency to the user experience.
    - The UI notification should be non-blocking and dismiss automatically.
  </constraints>
  <interfaces>
      <interface>
        <name>/api/suggest response</name>
        <kind>REST endpoint</kind>
        <signature>{"priority": "...", "label": "...", "fallback": true/false}</signature>
        <path>app.py</path>
      </interface>
  </interfaces>
  <tests>
    <standards>
- Unit Tests: `pytest`
- Integration/API Tests: `pytest` with `pytest-mock`
- E2E Tests: `Playwright`
    </standards>
    <locations>
- `tests/`
    </locations>
    <ideas>
- **Unit Test**: Mock a failed Gemini API call and verify the fallback logic in `ai_service.py` returns the correct keyword-based or default suggestion.
- **Integration Test**: Mock the `ai_service` to simulate a fallback and verify the `/api/suggest` endpoint returns the `fallback: true` flag.
- **E2E Test**: Mock the `/api/suggest` endpoint to return a fallback response and verify the toast notification appears in the UI.
    </ideas>
  </tests>
</story-context>